Round Robin 
 
#include <iostream> 
#include <queue> 
#include <iomanip> 
#include <climits> 
using namespace std; 
 
struct Process { 
    int pid;   // Process ID 
    int at;    // Arrival Time 
    int bt;    // Burst Time 
    int ct;    // Completion Time 
    int tat;   // Turnaround Time 
    int wt;    // Waiting Time 
    int rt;    // Remaining Time 
}; 
 
struct Slot { 
    int pid; 
    int start; 
    int end; 
}; 
 
// Round Robin Scheduling (Preemptive) 
int roundRobin(Process proc[], int n, int tq, Slot slots[]) { 
    queue<int> q; 
    int time = 0, completed = 0, k = 0; 
    bool inQueue[n] = {false}; 
 
    for (int i = 0; i < n; i++) 
        proc[i].rt = proc[i].bt; 
 
    // Find earliest arrival 
    int minArrival = proc[0].at; 
    for (int i = 1; i < n; i++) 
        if (proc[i].at < minArrival) 
            minArrival = proc[i].at; 
    time = minArrival; 
 
    while (completed < n) { 
        // Add all arrived processes 
        for (int i = 0; i < n; i++) { 
            if (!inQueue[i] && proc[i].at <= time && proc[i].rt > 0) { 
                q.push(i); 
                inQueue[i] = true; 
            } 
        } 
 
        // If no process available, jump to next arrival 
        if (q.empty()) { 
            int nextArrival = INT_MAX; 
            for (int i = 0; i < n; i++) { 
                if (proc[i].rt > 0 && proc[i].at > time) 
                    nextArrival = min(nextArrival, proc[i].at); 
            } 
            time = nextArrival; 
            continue; 
        } 
 
        int idx = q.front(); 
        q.pop(); 
 
        slots[k].pid = proc[idx].pid; 
        slots[k].start = time; 
 
        int execTime = min(tq, proc[idx].rt); 
        proc[idx].rt -= execTime; 
        time += execTime; 
        slots[k].end = time; 
 
        // Add new arrivals during this time slice 
        for (int i = 0; i < n; i++) { 
            if (!inQueue[i] && proc[i].at <= time && proc[i].rt > 0) { 
                q.push(i); 
                inQueue[i] = true; 
            } 
        } 
 
        // If not finished, put it back in queue 
        if (proc[idx].rt > 0) 
            q.push(idx); 
        else { 
            proc[idx].ct = time; 
            proc[idx].tat = proc[idx].ct - proc[idx].at; 
            proc[idx].wt = proc[idx].tat - proc[idx].bt; 
            completed++; 
        } 
 
        // Merge consecutive same process slots 
        if (k > 0 && slots[k].pid == slots[k - 1].pid) { 
            slots[k - 1].end = slots[k].end; 
            k--; 
        } 
 
        k++; 
    } 
 
    return k; 
} 
 
// Display process details 
void display(Process proc[], int n) { 
    float totalWT = 0, totalTAT = 0; 
 
    cout << "\nProcess\tAT\tBT\tCT\tTAT\tWT\n"; 
    for (int i = 0; i < n; i++) { 
        cout << "P" << proc[i].pid << "\t" << proc[i].at << "\t" << proc[i].bt 
             << "\t" << proc[i].ct << "\t" << proc[i].tat << "\t" << proc[i].wt << "\n"; 
        totalWT += proc[i].wt; 
        totalTAT += proc[i].tat; 
    } 
 
    cout << "\nAverage Turnaround Time = " << totalTAT / n; 
    cout << "\nAverage Waiting Time = " << totalWT / n << endl; 
} 
 
// Simple Gantt Chart (no idle) 
void showGantt(Slot slots[], int k) { 
    cout << "\nGantt Chart (Round Robin):\n"; 
 
    for (int i = 0; i < k; i++) { 
        cout << "| P" << slots[i].pid << " "; 
    } 
    cout << "|\n"; 
 
    cout << slots[0].start; 
    for (int i = 0; i < k; i++) { 
        cout << "   " << slots[i].end; 
    } 
    cout << "\n"; 
} 
 
int main() { 
    int n, tq; 
    cout << "Enter number of processes: "; 
    cin >> n; 
 
    Process proc[n]; 
    for (int i = 0; i < n; i++) { 
        cout << "Enter Arrival Time and Burst Time for Process " << i + 1 << ": "; 
        cin >> proc[i].at >> proc[i].bt; 
        proc[i].pid = i + 1; 
    } 
 
    cout << "Enter Time Quantum: "; 
    cin >> tq; 
 
    Slot slots[500]; 
    int k = roundRobin(proc, n, tq, slots); 
 
    display(proc, n); 
    showGantt(slots, k); 
 
    return 0; 
} 
 
Priority ( Non Preemptive ) 
 
#include <iostream> 
#include <iomanip> 
#include <climits> 
using namespace std; 
 
struct Process { 
    int pid;   // Process ID 
    int at;    // Arrival Time 
    int bt;    // Burst Time 
    int pr;    // Priority (lower number = higher priority) 
    int ct;    // Completion Time 
    int tat;   // Turnaround Time 
    int wt;    // Waiting Time 
    bool done; // Finished or not 
}; 
 
struct Slot { 
    int pid; 
    int start; 
    int end; 
}; 
 
// Priority Scheduling (Non-Preemptive) 
int priorityScheduling(Process proc[], int n, Slot slots[]) { 
    int time = 0, completed = 0, k = 0; 
 
    // Start from the earliest arrival 
    int firstArrival = proc[0].at; 
    for (int i = 1; i < n; i++) 
        if (proc[i].at < firstArrival) 
            firstArrival = proc[i].at; 
    time = firstArrival; 
 
    while (completed < n) { 
        int idx = -1, bestPr = INT_MAX; 
 
        // Find process with highest priority (lowest number) among arrived ones 
        for (int i = 0; i < n; i++) { 
            if (!proc[i].done && proc[i].at <= time) { 
                if (proc[i].pr < bestPr) { 
                    bestPr = proc[i].pr; 
                    idx = i; 
                }  
                else if (proc[i].pr == bestPr && proc[i].at < proc[idx].at) { 
                    idx = i; 
                } 
            } 
        } 
 
        // If no process arrived yet, jump to next arrival (skip idle) 
        if (idx == -1) { 
            int nextArrival = INT_MAX; 
            for (int i = 0; i < n; i++) 
                if (!proc[i].done && proc[i].at > time) 
                    nextArrival = min(nextArrival, proc[i].at); 
            time = nextArrival; 
            continue; 
        } 
 
        // Record process execution in Gantt chart 
        slots[k].pid = proc[idx].pid; 
        slots[k].start = time; 
 
        time += proc[idx].bt; 
        proc[idx].ct = time; 
        proc[idx].tat = proc[idx].ct - proc[idx].at; 
        proc[idx].wt = proc[idx].tat - proc[idx].bt; 
        proc[idx].done = true; 
 
        slots[k].end = time; 
        k++; 
        completed++; 
    } 
    return k; 
} 
 
// Display process table 
void display(Process proc[], int n) { 
    float totalWT = 0, totalTAT = 0; 
 
    cout << "\nProcess\tAT\tBT\tPR\tCT\tTAT\tWT\n"; 
    for (int i = 0; i < n; i++) { 
        cout << "P" << proc[i].pid << "\t"  
             << proc[i].at << "\t" << proc[i].bt << "\t"  
             << proc[i].pr << "\t" << proc[i].ct << "\t"  
             << proc[i].tat << "\t" << proc[i].wt << "\n"; 
 
        totalWT += proc[i].wt; 
        totalTAT += proc[i].tat; 
    } 
 
    cout << "\nAverage Turnaround Time = " << totalTAT / n; 
    cout << "\nAverage Waiting Time = " << totalWT / n << endl; 
} 
 
// Simple Gantt Chart (no idle) 
void printGanttChart(Slot slots[], int k) { 
    cout << "\nGantt Chart (Priority Non-Preemptive):\n"; 
 
    for (int i = 0; i < k; i++) { 
        cout << "| P" << slots[i].pid << " "; 
    } 
    cout << "|\n"; 
 
    cout << slots[0].start; 
    for (int i = 0; i < k; i++) { 
        cout << "   " << slots[i].end; 
    } 
    cout << "\n"; 
} 
 
int main() { 
    int n; 
    cout << "Enter number of processes: "; 
    cin >> n; 
 
    Process proc[n]; 
    for (int i = 0; i < n; i++) { 
        cout << "Enter Arrival Time, Burst Time, and Priority for Process " << i + 1 << ": "; 
        cin >> proc[i].at >> proc[i].bt >> proc[i].pr; 
        proc[i].pid = i + 1; 
proc[i].done = false; 
} 
Slot slots[200]; 
int k = priorityScheduling(proc, n, slots); 
display(proc, n); 
printGanttChart(slots, k); 
return 0; 
}