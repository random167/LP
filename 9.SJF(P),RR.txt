SJF ( Preemptive )  
 
#include <iostream> 
#include <climits> 
using namespace std; 
 
struct Process { 
    int pid;  // Process ID 
    int at;   // Arrival Time 
    int bt;   // Burst Time 
    int ct;   // Completion Time 
    int tat;  // Turnaround Time 
    int wt;   // Waiting Time 
    int rt;   // Remaining Time 
}; 
 
struct Slot { 
    int pid;   // process id (-1 = idle) 
    int start; // start time 
    int end;   // end time 
}; 
 
// Function to calculate times (SJF Preemptive) 
int calculate(Process p[], int n, Slot slots[]) { 
    int time = 0, completed = 0; 
    int prev = -2, k = 0; 
 
    // Initialize slots array to avoid garbage values 
    for (int i = 0; i < 200; i++) { 
        slots[i].pid = -2; 
        slots[i].start = slots[i].end = 0; 
    } 
 
    while (completed < n) { 
        int idx = -1, minRT = INT_MAX; 
 
        // Find process with minimum remaining time among arrived processes 
        for (int i = 0; i < n; i++) { 
            if (p[i].at <= time && p[i].rt > 0) { 
                if (p[i].rt < minRT) { 
                    minRT = p[i].rt; 
                    idx = i; 
                } else if (p[i].rt == minRT && p[i].at < p[idx].at) { 
                    idx = i; 
                } 
            } 
        } 
 
        if (idx == -1) { // CPU idle 
            if (prev != -1) { 
                if (prev != -2) { 
                    slots[k].end = time; 
                    k++; 
                } 
                slots[k].pid = -1; // idle slot 
                slots[k].start = time; 
            } 
            prev = -1; 
            time++; 
        } else { 
            if (prev != p[idx].pid) { 
                if (prev != -2) { 
                    slots[k].end = time; 
                    k++; 
                } 
                slots[k].pid = p[idx].pid; 
                slots[k].start = time; 
                prev = p[idx].pid; 
            } 
 
            p[idx].rt--; 
            time++; 
 
            if (p[idx].rt == 0) { 
                p[idx].ct = time; 
                p[idx].tat = p[idx].ct - p[idx].at; 
                p[idx].wt = p[idx].tat - p[idx].bt; 
                completed++; 
            } 
        } 
    } 
 
    slots[k].end = time; 
    k++; 
    return k; 
} 
 
// Display process info and averages 
void showTable(Process p[], int n) { 
    float totalWT = 0, totalTAT = 0; 
 
    cout << "\nProcess\tAT\tBT\tCT\tTAT\tWT\n"; 
    for (int i = 0; i < n; i++) { 
        cout << "P" << p[i].pid << "\t" << p[i].at << "\t" << p[i].bt 
             << "\t" << p[i].ct << "\t" << p[i].tat << "\t" << p[i].wt << "\n"; 
        totalWT += p[i].wt; 
        totalTAT += p[i].tat; 
    } 
 
    cout << "\nAverage Turnaround Time = " << totalTAT / n; 
    cout << "\nAverage Waiting Time = " << totalWT / n << endl; 
} 
 
// Simple Gantt chart display (skip initial idle) 
void showGantt(Slot slots[], int k) { 
    cout << "\nGantt Chart (SJF Preemptive):\n"; 
 
    int startIdx = 0; 
    // Skip initial idle (if CPU was idle before first process) 
    if (slots[0].pid == -1) 
        startIdx = 1; 
 
    for (int i = startIdx; i < k; i++) { 
        if (slots[i].pid == -1) 
            cout << "| IDLE "; 
        else 
            cout << "| P" << slots[i].pid << " "; 
    } 
    cout << "|\n"; 
 
    cout << slots[startIdx].start; 
    for (int i = startIdx; i < k; i++) { 
        cout << "   " << slots[i].end; 
    } 
    cout << "\n"; 
} 
 
int main() { 
    int n; 
    cout << "Enter number of processes: "; 
    cin >> n; 
 
    Process p[n]; 
    for (int i = 0; i < n; i++) { 
        cout << "Enter Arrival Time and Burst Time for Process " << i + 1 << ": "; 
        cin >> p[i].at >> p[i].bt; 
        p[i].pid = i + 1; 
        p[i].rt = p[i].bt; 
    } 
 
    Slot slots[200]; 
    int k = calculate(p, n, slots); 
 
    showTable(p, n); 
    showGantt(slots, k); 
 
    return 0; 
} 
 
 
Round Robin 
 
#include <iostream> 
#include <queue> 
#include <iomanip> 
#include <climits> 
using namespace std; 
 
struct Process { 
    int pid;   // Process ID 
    int at;    // Arrival Time 
    int bt;    // Burst Time 
    int ct;    // Completion Time 
    int tat;   // Turnaround Time 
    int wt;    // Waiting Time 
    int rt;    // Remaining Time 
}; 
 
struct Slot { 
    int pid; 
    int start; 
    int end; 
}; 
 
// Round Robin Scheduling Function 
int roundRobin(Process proc[], int n, int tq, Slot slots[]) { 
    queue<int> q; 
    int time = 0, completed = 0, k = 0; 
    bool inQueue[n] = {false}; 
 
    for (int i = 0; i < n; i++) 
        proc[i].rt = proc[i].bt; 
 
    // Start from the earliest arrival time 
    int minArrival = proc[0].at; 
    for (int i = 1; i < n; i++) 
        if (proc[i].at < minArrival) 
            minArrival = proc[i].at; 
    time = minArrival; 
 
    while (completed < n) { 
        // Add all processes that have arrived till current time 
        for (int i = 0; i < n; i++) { 
            if (!inQueue[i] && proc[i].at <= time && proc[i].rt > 0) { 
                q.push(i); 
                inQueue[i] = true; 
            } 
        } 
 
        // If no process has arrived, jump to next arrival (skip idle) 
        if (q.empty()) { 
            int nextArrival = INT_MAX; 
            for (int i = 0; i < n; i++) { 
                if (proc[i].rt > 0 && proc[i].at > time) 
                    nextArrival = min(nextArrival, proc[i].at); 
            } 
            time = nextArrival; 
            continue; 
        } 
 
        int idx = q.front(); 
        q.pop(); 
 
        slots[k].pid = proc[idx].pid; 
        slots[k].start = time; 
 
        int execTime = min(tq, proc[idx].rt); 
        proc[idx].rt -= execTime; 
        time += execTime; 
        slots[k].end = time; 
 
        // Add new arrivals during execution 
        for (int i = 0; i < n; i++) { 
            if (!inQueue[i] && proc[i].at <= time && proc[i].rt > 0) { 
                q.push(i); 
                inQueue[i] = true; 
            } 
        } 
 
        // If process not finished, push it back to queue 
        if (proc[idx].rt > 0) 
            q.push(idx); 
        else { 
            proc[idx].ct = time; 
            proc[idx].tat = proc[idx].ct - proc[idx].at; 
            proc[idx].wt = proc[idx].tat - proc[idx].bt; 
            completed++; 
        } 
 
        // Merge consecutive slots for same process 
        if (k > 0 && slots[k].pid == slots[k - 1].pid) { 
            slots[k - 1].end = slots[k].end; 
            k--; 
        } 
 
        k++; 
    } 
 
    return k; 
} 
 
// Display Process Table 
void display(Process proc[], int n) { 
    float totalWT = 0, totalTAT = 0; 
 
    cout << "\nProcess\tAT\tBT\tCT\tTAT\tWT\n"; 
    for (int i = 0; i < n; i++) { 
        cout << "P" << proc[i].pid << "\t" << proc[i].at << "\t" << proc[i].bt 
             << "\t" << proc[i].ct << "\t" << proc[i].tat << "\t" << proc[i].wt << "\n"; 
        totalWT += proc[i].wt; 
        totalTAT += proc[i].tat; 
    } 
 
    cout << "\nAverage Turnaround Time = " << totalTAT / n; 
    cout << "\nAverage Waiting Time = " << totalWT / n << endl; 
} 
 
// Simple Gantt Chart 
void showGantt(Slot slots[], int k) { 
    cout << "\nGantt Chart (Round Robin):\n"; 
    for (int i = 0; i < k; i++) { 
        cout << "| P" << slots[i].pid << " "; 
    } 
    cout << "|\n"; 
 
    cout << slots[0].start; 
    for (int i = 0; i < k; i++) { 
        cout << "   " << slots[i].end; 
    } 
    cout << "\n"; 
} 
 
int main() { 
    int n, tq; 
    cout << "Enter number of processes: "; 
    cin >> n; 
 
    Process proc[n]; 
    for (int i = 0; i < n; i++) { 
        cout << "Enter Arrival Time and Burst Time for Process " << i + 1 << ": "; 
        cin >> proc[i].at >> proc[i].bt; 
        proc[i].pid = i + 1; 
    } 
 
    cout << "Enter Time Quantum: "; 
    cin >> tq; 
 
    Slot slots[500]; 
    int k = roundRobin(proc, n, tq, slots); 
 
    display(proc, n); 
    showGantt(slots, k); 
 
    return 0; 
}